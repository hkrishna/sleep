<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brooklyn Towers Sleep Advisor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }
        .emoji-main {
            font-size: 8rem;
            line-height: 1;
            cursor: pointer;
            transition: transform 0.3s ease;
        }
        .emoji-main img {
            width: 8rem;
            height: auto;
            display: block;
        }
        .emoji-main:hover {
            transform: scale(1.1);
        }
        .emoji-main:active {
            transform: scale(0.95);
        }
        .emoji-small {
            font-size: 2.5rem;
            line-height: 1;
        }
        .emoji-small img {
            width: 2.5rem;
            height: auto;
            display: block;
        }
        @media (max-width: 640px) {
            .emoji-main {
                font-size: 6rem;
            }
            .emoji-main img {
                width: 6rem;
            }
            .emoji-small {
                font-size: 2rem;
            }
            .emoji-small img {
                width: 2rem;
            }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 min-h-screen">
    <div id="app" class="flex items-center justify-center min-h-screen p-4">
        <div class="text-center">
            <div class="w-12 h-12 border-4 border-amber-400 border-t-transparent rounded-full animate-spin mx-auto mb-4"></div>
            <p class="text-slate-300 text-lg">Checking winds...</p>
        </div>
    </div>

    <script>
        const API_KEY = '5288d5a78ce0e73bdd53f0b8fe3a28c3';
        const LAT = 40.69056;
        const LON = -73.9822;
        const USE_DEMO_MODE = API_KEY === 'YOUR_API_KEY_HERE';
        const CACHE_DURATION = 30 * 60 * 1000; // 30 minutes

        let forecastData = null;
        let rawForecastList = null;
        let isDemoMode = false;
        let showingNow = true; // true = showing "now", false = showing "later" (5-day forecast)

        function getETTime() {
            const now = new Date();
            return new Date(now.toLocaleString("en-US", {timeZone: "America/New_York"}));
        }

        function getWeatherEmoji(weatherData) {
            if (!weatherData || !weatherData.weather || weatherData.weather.length === 0) {
                return 'üå§Ô∏è'; // Default
            }
            
            const main = weatherData.weather[0].main.toLowerCase();
            const description = weatherData.weather[0].description.toLowerCase();
            const windSpeed = weatherData.wind ? Math.round(weatherData.wind.speed) : 0;
            
            // Check for wind first (if very windy, show wind emoji)
            if (windSpeed >= 20) {
                return 'üí®';
            }
            
            // Map weather conditions to emojis
            if (main === 'clear') {
                return '‚òÄÔ∏è';
            } else if (main === 'clouds') {
                if (description.includes('few') || description.includes('scattered')) {
                    return '‚õÖ';
                } else {
                    return '‚òÅÔ∏è';
                }
            } else if (main === 'rain') {
                if (description.includes('drizzle')) {
                    return 'üå¶Ô∏è';
                } else if (description.includes('thunderstorm')) {
                    return '‚õàÔ∏è';
                } else {
                    return 'üåßÔ∏è';
                }
            } else if (main === 'drizzle') {
                return 'üå¶Ô∏è';
            } else if (main === 'thunderstorm') {
                return '‚õàÔ∏è';
            } else if (main === 'snow') {
                return '‚ùÑÔ∏è';
            } else if (main === 'mist' || main === 'fog' || main === 'haze') {
                return 'üå´Ô∏è';
            } else if (windSpeed >= 15) {
                return 'üí®';
            } else {
                return 'üå§Ô∏è';
            }
        }

        function getCurrentWind(forecastList) {
            if (!forecastList || forecastList.length === 0) return null;
            
            const now = new Date();
            const nowUnix = Math.floor(now.getTime() / 1000);
            
            // Find the closest forecast entry to current time
            let closest = forecastList[0];
            let minDiff = Math.abs(closest.dt - nowUnix);
            
            for (const item of forecastList) {
                const diff = Math.abs(item.dt - nowUnix);
                if (diff < minDiff) {
                    minDiff = diff;
                    closest = item;
                }
            }
            
            const windSpeed = Math.round(closest.wind.speed);
            const windGust = closest.wind.gust ? Math.round(closest.wind.gust) : windSpeed;
            const maxWind = Math.max(windSpeed, windGust);
            
            return {
                speed: windSpeed,
                gust: windGust,
                maxWind: maxWind,
                shouldSleepInStudy: maxWind >= 20,
                weatherEmoji: getWeatherEmoji(closest),
                weatherData: closest
            };
        }

        function formatTimeET(date) {
            const etDate = new Date(date.toLocaleString("en-US", {timeZone: "America/New_York"}));
            const hours = etDate.getHours();
            const minutes = etDate.getMinutes();
            const ampm = hours >= 12 ? 'PM' : 'AM';
            const displayHours = hours % 12 || 12;
            const displayMinutes = minutes > 0 ? `:${minutes.toString().padStart(2, '0')}` : '';
            return `${displayHours}${displayMinutes}${ampm}`;
        }

        function formatDuration(mins) {
            if (mins === 0) return '0 mins';
            const hours = Math.floor(mins / 60);
            const remainingMins = mins % 60;
            
            if (hours === 0) {
                return `${remainingMins} mins`;
            } else if (remainingMins === 0) {
                return `${hours} hour${hours > 1 ? 's' : ''}`;
            } else {
                return `${hours} hour${hours > 1 ? 's' : ''} ${remainingMins} mins`;
            }
        }

        function getWindyPeriods(forecastList) {
            if (!forecastList || forecastList.length === 0) return [];
            
            const etNow = getETTime();
            const nowUnix = Math.floor(etNow.getTime() / 1000);
            
            // Get end time: 7AM ET next day
            const nextMorning = new Date(etNow);
            nextMorning.setDate(nextMorning.getDate() + 1);
            nextMorning.setHours(7, 0, 0, 0);
            const nextMorningUnix = Math.floor(nextMorning.getTime() / 1000);
            
            // Get all forecast entries from now until 7AM ET next day
            const filtered = forecastList
                .filter(item => item.dt >= nowUnix && item.dt <= nextMorningUnix)
                .sort((a, b) => a.dt - b.dt);
            
            const relevantPeriods = filtered.map((item, index, array) => {
                const itemTime = new Date(item.dt * 1000);
                const itemET = new Date(itemTime.toLocaleString("en-US", {timeZone: "America/New_York"}));
                const windSpeed = Math.round(item.wind.speed);
                const windGust = item.wind.gust ? Math.round(item.wind.gust) : windSpeed;
                const maxWind = Math.max(windSpeed, windGust);
                
                // Each forecast represents a 3-hour period
                // For the first period, start from current time if it's the closest forecast
                let startTime = itemET;
                if (index === 0) {
                    // Use current time if it's after the forecast time
                    const currentET = new Date(etNow.toLocaleString("en-US", {timeZone: "America/New_York"}));
                    if (currentET > itemET) {
                        startTime = currentET;
                    }
                }
                
                // End time is 3 hours later (or next forecast, whichever comes first)
                let endTime;
                if (index < array.length - 1) {
                    const nextItemTime = new Date(array[index + 1].dt * 1000);
                    endTime = new Date(nextItemTime.toLocaleString("en-US", {timeZone: "America/New_York"}));
                } else {
                    // Last period - extend to 7AM or 3 hours from original forecast start, whichever is earlier
                    const threeHoursLater = new Date(itemET.getTime() + 3 * 60 * 60 * 1000);
                    endTime = threeHoursLater < nextMorning ? threeHoursLater : nextMorning;
                }
                
                return {
                    dt: item.dt,
                    startTime: startTime,
                    endTime: endTime,
                    maxWind: maxWind,
                    isWindy: maxWind >= 20
                };
            });
            
            if (relevantPeriods.length === 0) return [];
            
            // Group consecutive windy periods
            const windyPeriods = [];
            let currentPeriod = null;
            
            for (let i = 0; i < relevantPeriods.length; i++) {
                const period = relevantPeriods[i];
                
                if (period.isWindy) {
                    if (!currentPeriod) {
                        // Start a new windy period
                        currentPeriod = {
                            start: period.startTime,
                            end: period.endTime
                        };
                    } else {
                        // Extend current period - merge with previous
                        currentPeriod.end = period.endTime;
                    }
                } else {
                    if (currentPeriod) {
                        // End current period
                        windyPeriods.push(currentPeriod);
                        currentPeriod = null;
                    }
                }
            }
            
            // Add final period if still active
            if (currentPeriod) {
                windyPeriods.push(currentPeriod);
            }
            
            // Calculate durations and format, with day/night classification
            return windyPeriods.map(period => {
                const durationMs = period.end.getTime() - period.start.getTime();
                const durationMins = Math.round(durationMs / (1000 * 60));
                
                // Determine if period spans day/night boundary
                const startHour = period.start.getHours();
                const endHour = period.end.getHours();
                
                // Daytime: 7AM-7PM (7-19), Nighttime: 7PM-7AM (19-7)
                let dayMins = 0;
                let nightMins = 0;
                
                // Split period into day and night portions
                let currentTime = new Date(period.start);
                const endTime = new Date(period.end);
                
                while (currentTime < endTime) {
                    const currentHour = currentTime.getHours();
                    const isDaytime = currentHour >= 7 && currentHour < 19;
                    
                    // Find next boundary (7AM or 7PM) or end of period
                    let nextBoundary = new Date(currentTime);
                    if (isDaytime) {
                        // Currently daytime, next boundary is 7PM
                        nextBoundary.setHours(19, 0, 0, 0);
                    } else {
                        // Currently nighttime, next boundary is 7AM next day
                        nextBoundary.setDate(nextBoundary.getDate() + 1);
                        nextBoundary.setHours(7, 0, 0, 0);
                    }
                    
                    const segmentEnd = nextBoundary < endTime ? nextBoundary : endTime;
                    const segmentMins = Math.round((segmentEnd.getTime() - currentTime.getTime()) / (1000 * 60));
                    
                    if (isDaytime) {
                        dayMins += segmentMins;
                    } else {
                        nightMins += segmentMins;
                    }
                    
                    currentTime = segmentEnd;
                }
                
                // Determine emoji based on start time (if period spans both, use the one with more minutes)
                // If period spans both day and night, use the one with more minutes
                const isDaytime = dayMins >= nightMins ? true : false;
                const emoji = isDaytime ? '‚òÄÔ∏è' : 'üåô';
                
                return {
                    startTime: formatTimeET(period.start),
                    endTime: formatTimeET(period.end),
                    durationMins: durationMins,
                    dayMins: dayMins,
                    nightMins: nightMins,
                    emoji: emoji
                };
            });
        }

        function getTonightForecast(forecastList) {
            if (!forecastList || forecastList.length === 0) return null;
            
            const etNow = getETTime();
            const etHour = etNow.getHours();
            
            // If it's already past 9PM ET, tonight has already started
            let targetDate = new Date(etNow);
            if (etHour >= 21) {
                // Already in tonight, so "tonight" is the current night
                targetDate.setHours(21, 0, 0, 0);
            } else {
                // Before 9PM, so tonight starts at 9PM today
                targetDate.setHours(21, 0, 0, 0);
            }
            
            const nextMorning = new Date(targetDate);
            nextMorning.setHours(31, 0, 0, 0); // 7AM next day
            
            const nightPeriods = forecastList.filter(item => {
                const itemTime = new Date(item.dt * 1000);
                const itemET = new Date(itemTime.toLocaleString("en-US", {timeZone: "America/New_York"}));
                const hour = itemET.getHours();
                return itemET >= targetDate && itemET <= nextMorning &&
                       (hour >= 21 || hour < 7);
            });
            
            if (nightPeriods.length === 0) return null;
            
            const windSpeeds = nightPeriods.map(item => {
                const windSpeed = Math.round(item.wind.speed);
                const windGust = item.wind.gust ? Math.round(item.wind.gust) : windSpeed;
                return Math.max(windSpeed, windGust);
            });
            
            const maxWind = Math.max(...windSpeeds);
            
            // Get weather from the first nighttime period
            const firstNightPeriod = nightPeriods[0];
            const weatherEmoji = getWeatherEmoji(firstNightPeriod);
            
            // Get windy periods from now until next day 7AM
            const windyPeriods = getWindyPeriods(forecastList);
            const totalWindyMins = windyPeriods.reduce((sum, p) => sum + p.durationMins, 0);
            
            // Calculate daytime (current time to 7PM today) and nighttime (7PM to 7AM next day) windy times
            const today7PM = new Date(etNow);
            today7PM.setHours(19, 0, 0, 0); // 7PM today
            if (today7PM < etNow) {
                // Already past 7PM, no daytime period
                today7PM.setDate(today7PM.getDate() + 1);
            }
            
            const nextDay7AM = new Date(etNow);
            nextDay7AM.setDate(nextDay7AM.getDate() + 1);
            nextDay7AM.setHours(7, 0, 0, 0); // 7AM next day
            
            let dayWindyMins = 0;
            let nightWindyMins = 0;
            
            for (const period of windyPeriods) {
                dayWindyMins += period.dayMins || 0;
                nightWindyMins += period.nightMins || 0;
            }
            
            // Check if we're currently in nighttime (after 7PM or before 7AM)
            const isCurrentlyNighttime = etHour >= 19 || etHour < 7;
            
            return {
                maxWind: maxWind,
                shouldSleepInStudy: maxWind >= 20,
                weatherEmoji: weatherEmoji,
                windyPeriods: windyPeriods,
                totalWindyMins: totalWindyMins,
                dayWindyMins: dayWindyMins,
                nightWindyMins: nightWindyMins,
                isCurrentlyNighttime: isCurrentlyNighttime
            };
        }

        async function fetchWeatherData() {
            try {
                const cachedData = getCachedWeather();
                if (cachedData) {
                    console.log('Using cached weather data');
                    forecastData = cachedData.forecast;
                    rawForecastList = cachedData.rawForecastList;
                    isDemoMode = cachedData.isDemo;
                    renderSimple(cachedData.forecast, cachedData.isDemo);
                    return;
                }

                if (USE_DEMO_MODE) {
                    const demoData = generateDemoData();
                    rawForecastList = demoData;
                    const forecast = analyzeForecast(demoData);
                    forecastData = forecast;
                    isDemoMode = true;
                    cacheWeatherData(forecast, demoData, true);
                    renderSimple(forecast, true);
                    return;
                }

                console.log('Fetching fresh weather data from API...');
                const response = await fetch(
                    `https://api.openweathermap.org/data/2.5/forecast?lat=${LAT}&lon=${LON}&appid=${API_KEY}&units=imperial`
                );
                
                if (!response.ok) {
                    if (response.status === 401) {
                        throw new Error('Invalid API key');
                    }
                    throw new Error(`API error: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (!data.list || data.list.length === 0) {
                    throw new Error('No forecast data available');
                }
                
                rawForecastList = data.list;
                const forecast = analyzeForecast(data.list);
                forecastData = forecast;
                isDemoMode = false;
                cacheWeatherData(forecast, data.list, false);
                renderSimple(forecast, false);
            } catch (error) {
                console.error('Weather fetch error:', error);
                renderError(error.message);
            }
        }

        function generateDemoData() {
            const now = new Date();
            const data = [];
            const weatherTypes = [
                { main: 'Clear', description: 'clear sky' },
                { main: 'Clouds', description: 'few clouds' },
                { main: 'Clouds', description: 'scattered clouds' },
                { main: 'Clouds', description: 'broken clouds' },
                { main: 'Clouds', description: 'overcast clouds' },
                { main: 'Rain', description: 'light rain' },
                { main: 'Rain', description: 'moderate rain' },
                { main: 'Rain', description: 'heavy rain' },
                { main: 'Drizzle', description: 'light drizzle' },
                { main: 'Thunderstorm', description: 'thunderstorm' }
            ];
            
            for (let i = 0; i < 120; i++) { // 5 days of 3-hour intervals
                const time = new Date(now.getTime() + (i * 3 * 60 * 60 * 1000));
                const hour = time.getHours();
                
                let baseWind = 8 + Math.random() * 8;
                if (hour >= 21 || hour < 7) {
                    baseWind += Math.random() * 12;
                }
                
                // Random weather type
                const weatherType = weatherTypes[Math.floor(Math.random() * weatherTypes.length)];
                
                data.push({
                    dt: time.getTime() / 1000,
                    wind: {
                        speed: Math.round(baseWind),
                        gust: Math.round(baseWind + Math.random() * 5)
                    },
                    weather: [{
                        main: weatherType.main,
                        description: weatherType.description
                    }]
                });
            }
            
            return data;
        }

        function calculateWindyTimeForDay(forecastList, startDate, endDate) {
            // Convert startDate and endDate to ET timezone for proper comparison
            const startET = new Date(startDate.toLocaleString("en-US", {timeZone: "America/New_York"}));
            const endET = new Date(endDate.toLocaleString("en-US", {timeZone: "America/New_York"}));
            
            // Get all forecast entries for this day's night period (same logic as analyzeForecast)
            const nightPeriods = forecastList.filter(item => {
                const itemTime = new Date(item.dt * 1000);
                const itemET = new Date(itemTime.toLocaleString("en-US", {timeZone: "America/New_York"}));
                const hour = itemET.getHours();
                return itemET >= startET && itemET <= endET &&
                       (hour >= 21 || hour < 7);
            });
            
            if (nightPeriods.length === 0) return 0;
            
            // Sort by time
            nightPeriods.sort((a, b) => a.dt - b.dt);
            
            // Calculate windy periods
            let totalWindyMins = 0;
            
            for (let i = 0; i < nightPeriods.length; i++) {
                const item = nightPeriods[i];
                const itemTime = new Date(item.dt * 1000);
                const itemET = new Date(itemTime.toLocaleString("en-US", {timeZone: "America/New_York"}));
                const windSpeed = Math.round(item.wind.speed);
                const windGust = item.wind.gust ? Math.round(item.wind.gust) : windSpeed;
                const maxWind = Math.max(windSpeed, windGust);
                
                if (maxWind >= 20) {
                    // Determine the period this forecast covers
                    let periodStart = itemET;
                    let periodEnd;
                    
                    if (i === 0 && startET > itemET) {
                        periodStart = startET;
                    }
                    
                    if (i < nightPeriods.length - 1) {
                        const nextItemTime = new Date(nightPeriods[i + 1].dt * 1000);
                        periodEnd = new Date(nextItemTime.toLocaleString("en-US", {timeZone: "America/New_York"}));
                    } else {
                        // Last period - extend to endDate or 3 hours, whichever comes first
                        const threeHoursLater = new Date(itemET.getTime() + 3 * 60 * 60 * 1000);
                        periodEnd = threeHoursLater < endET ? threeHoursLater : endET;
                    }
                    
                    const durationMs = periodEnd.getTime() - periodStart.getTime();
                    const durationMins = Math.round(durationMs / (1000 * 60));
                    totalWindyMins += Math.max(0, durationMins);
                }
            }
            
            return totalWindyMins;
        }

        function analyzeForecast(forecastList) {
            const dailyForecasts = [];
            const etNow = getETTime();
            
            // Group by date and analyze nighttime winds (9PM-7AM ET)
            for (let dayOffset = 0; dayOffset < 5; dayOffset++) {
                const targetDate = new Date(etNow);
                targetDate.setDate(targetDate.getDate() + dayOffset);
                targetDate.setHours(21, 0, 0, 0); // 9PM ET
                
                const nextMorning = new Date(targetDate);
                nextMorning.setHours(31, 0, 0, 0); // 7AM next day ET
                
                const nightPeriods = forecastList.filter(item => {
                    const itemTime = new Date(item.dt * 1000);
                    const itemET = new Date(itemTime.toLocaleString("en-US", {timeZone: "America/New_York"}));
                    const hour = itemET.getHours();
                    return itemET >= targetDate && itemET <= nextMorning &&
                           (hour >= 21 || hour < 7);
                });
                
                if (nightPeriods.length === 0) continue;
                
                const windSpeeds = nightPeriods.map(item => {
                    const windSpeed = Math.round(item.wind.speed);
                    const windGust = item.wind.gust ? Math.round(item.wind.gust) : windSpeed;
                    return Math.max(windSpeed, windGust);
                });
                
                const maxWind = Math.max(...windSpeeds);
                const avgWind = Math.round(windSpeeds.reduce((a, b) => a + b, 0) / windSpeeds.length);
                
                // Calculate windy time for full day (7AM-7AM) broken down by day/night
                // Use the same filtering approach as nightPeriods but for the full day
                const dayStart = new Date(etNow);
                dayStart.setDate(dayStart.getDate() + dayOffset);
                dayStart.setHours(7, 0, 0, 0); // 7AM of target day
                
                const dayEnd = new Date(dayStart);
                dayEnd.setDate(dayEnd.getDate() + 1); // 7AM next day
                
                // Get all periods for the full day (7AM-7AM) - same logic as nightPeriods
                const allDayPeriods = forecastList.filter(item => {
                    const itemTime = new Date(item.dt * 1000);
                    const itemET = new Date(itemTime.toLocaleString("en-US", {timeZone: "America/New_York"}));
                    // Check if item falls within the day range (7AM to 7AM next day)
                    return itemET >= dayStart && itemET < dayEnd;
                }).sort((a, b) => a.dt - b.dt);
                
                let dayWindyMins = 0;
                let nightWindyMins = 0;
                let totalWindyMins = 0;
                
                for (let i = 0; i < allDayPeriods.length; i++) {
                    const item = allDayPeriods[i];
                    const itemTime = new Date(item.dt * 1000);
                    const itemET = new Date(itemTime.toLocaleString("en-US", {timeZone: "America/New_York"}));
                    const windSpeed = Math.round(item.wind.speed);
                    const windGust = item.wind.gust ? Math.round(item.wind.gust) : windSpeed;
                    const maxWindForPeriod = Math.max(windSpeed, windGust);
                    
                    if (maxWindForPeriod >= 20) {
                        let periodStart = itemET;
                        let periodEnd;
                        
                        if (i === 0 && dayStart > itemET) {
                            periodStart = dayStart;
                        }
                        
                        if (i < allDayPeriods.length - 1) {
                            const nextItemTime = new Date(allDayPeriods[i + 1].dt * 1000);
                            periodEnd = new Date(nextItemTime.toLocaleString("en-US", {timeZone: "America/New_York"}));
                        } else {
                            const threeHoursLater = new Date(itemET.getTime() + 3 * 60 * 60 * 1000);
                            periodEnd = threeHoursLater < dayEnd ? threeHoursLater : dayEnd;
                        }
                        
                        // Split period into day and night portions
                        let currentTime = new Date(periodStart);
                        const endTime = new Date(periodEnd);
                        
                        while (currentTime < endTime) {
                            const currentHour = currentTime.getHours();
                            const isDaytime = currentHour >= 7 && currentHour < 19;
                            
                            // Find next boundary (7AM or 7PM) or end of period
                            let nextBoundary = new Date(currentTime);
                            if (isDaytime) {
                                nextBoundary.setHours(19, 0, 0, 0);
                            } else {
                                if (currentHour >= 19) {
                                    nextBoundary.setDate(nextBoundary.getDate() + 1);
                                }
                                nextBoundary.setHours(7, 0, 0, 0);
                            }
                            
                            const segmentEnd = nextBoundary < endTime ? nextBoundary : endTime;
                            const segmentMins = Math.round((segmentEnd.getTime() - currentTime.getTime()) / (1000 * 60));
                            
                            if (isDaytime) {
                                dayWindyMins += segmentMins;
                            } else {
                                nightWindyMins += segmentMins;
                            }
                            
                            currentTime = segmentEnd;
                        }
                        
                        const durationMs = periodEnd.getTime() - periodStart.getTime();
                        const durationMins = Math.round(durationMs / (1000 * 60));
                        totalWindyMins += Math.max(0, durationMins);
                    }
                }
                
                dailyForecasts.push({
                    date: targetDate,
                    maxWind: maxWind,
                    avgWind: avgWind,
                    shouldSleepInStudy: maxWind >= 20,
                    nightPeriods: nightPeriods.slice(0, 4),
                    windyTimeMins: totalWindyMins,
                    dayWindyMins: dayWindyMins,
                    nightWindyMins: nightWindyMins
                });
            }
            
            return dailyForecasts;
        }

        function getCachedWeather() {
            try {
                const cached = localStorage.getItem('weatherCache');
                if (!cached) return null;

                const data = JSON.parse(cached);
                const now = Date.now();
                
                if (now - data.timestamp < CACHE_DURATION) {
                    return data;
                }
                
                localStorage.removeItem('weatherCache');
                return null;
            } catch (e) {
                console.error('Error reading cache:', e);
                return null;
            }
        }

        function cacheWeatherData(forecast, rawForecastList, isDemo) {
            try {
                const cacheData = {
                    forecast: forecast,
                    rawForecastList: rawForecastList,
                    isDemo: isDemo,
                    timestamp: Date.now()
                };
                localStorage.setItem('weatherCache', JSON.stringify(cacheData));
                console.log('Weather data cached');
            } catch (e) {
                console.error('Error caching data:', e);
            }
        }

        function forceRefresh() {
            localStorage.removeItem('weatherCache');
            location.reload();
        }

        function toggleDetails() {
            // Always show the simple view with forecast
            renderSimple(forecastData, isDemoMode);
        }

        function renderSimple(forecast, isDemo) {
            if (!forecast || forecast.length === 0 || !rawForecastList) {
                renderError('No forecast data available');
                return;
            }

            const currentWind = getCurrentWind(rawForecastList);
            const tonightForecast = getTonightForecast(rawForecastList);
            
            if (!currentWind) {
                renderError('Unable to get current wind conditions');
                return;
            }
            
            // Current wind emoji: üé¢ if windy (>= 20 mph), üèôÔ∏è if not windy
            const currentEmoji = currentWind.maxWind >= 20 ? 'üé¢' : 'üèôÔ∏è';
            const statusText = currentWind.maxWind >= 20 ? 'Windy' : 'Calm';
            
            const cached = localStorage.getItem('weatherCache');
            const cacheAge = cached ? Date.now() - JSON.parse(cached).timestamp : 0;
            const minutesOld = Math.floor(cacheAge / 60000);
            
            document.getElementById('app').innerHTML = `
                <div class="max-w-2xl w-full text-center">
                    <h1 class="text-2xl font-semibold text-slate-200 mb-6">Brooklyn Towers Wind Conditions</h1>
                    
                    ${isDemo ? `
                        <div class="bg-amber-500/10 border border-amber-500/30 rounded-xl px-4 py-2 mb-8 inline-block">
                            <p class="text-amber-300 text-xs font-medium">DEMO MODE</p>
                        </div>
                    ` : minutesOld > 0 ? `
                        <div class="bg-slate-700/30 border border-slate-600/30 rounded-xl px-4 py-2 mb-8 inline-block">
                            <p class="text-slate-400 text-xs">Updated ${minutesOld} min ago</p>
                        </div>
                    ` : ''}
                    
                    <!-- Toggle switch -->
                    <div class="flex items-center justify-center mb-6">
                        <div class="bg-slate-700 rounded-full p-1 flex items-center relative">
                            <button onclick="showingNow = true; renderSimple(forecastData, isDemoMode);" 
                                    class="px-6 py-2 rounded-full text-sm font-medium transition-all relative z-10 ${
                                        showingNow 
                                            ? 'bg-amber-500 text-slate-900' 
                                            : 'text-slate-300 hover:text-slate-100'
                                    }">
                                Now
                            </button>
                            <button onclick="showingNow = false; renderSimple(forecastData, isDemoMode);" 
                                    class="px-6 py-2 rounded-full text-sm font-medium transition-all relative z-10 ${
                                        !showingNow 
                                            ? 'bg-amber-500 text-slate-900' 
                                            : 'text-slate-300 hover:text-slate-100'
                                    }">
                                Later
                            </button>
                        </div>
                    </div>
                    
                    ${showingNow ? `
                        <!-- Now view -->
                        <div class="select-none mb-8">
                            <div class="emoji-main">${currentEmoji}</div>
                            <p class="text-slate-400 text-sm mt-4">Right Now</p>
                            <p class="text-slate-500 text-xs mt-1">${statusText}</p>
                        </div>
                    ` : `
                        <!-- Later view - 5-day forecast -->
                        <div class="bg-slate-800/50 border border-slate-700 rounded-2xl p-6 mb-6">
                            <p class="text-slate-400 text-sm mb-4">5-Day Forecast</p>
                            <div class="space-y-3">
                                ${forecast.slice(0, 5).map((day, idx) => {
                                    const dayEmoji = day.shouldSleepInStudy ? 'üé¢' : 'üèôÔ∏è';
                                    const date = new Date(day.date);
                                    const dateStr = idx === 0 ? 'Tonight' : 
                                                   idx === 1 ? 'Tomorrow' :
                                                   date.toLocaleDateString('en-US', { weekday: 'long', month: 'short', day: 'numeric' });
                                    
                                    return `
                                        <div class="py-2 border-b border-slate-700/50 last:border-0">
                                            <div class="flex items-center justify-between mb-1">
                                                <div class="flex items-center gap-3 flex-1">
                                                    <span class="text-3xl">${dayEmoji}</span>
                                                    <span class="text-slate-300 text-sm">${dateStr}</span>
                                                </div>
                                                <div class="flex items-center gap-2">
                                                    <div class="w-24 bg-slate-700 rounded-full h-1.5 overflow-hidden">
                                                        <div class="h-full ${day.maxWind >= 20 ? 'bg-orange-400' : 'bg-emerald-400'}" 
                                                             style="width: ${Math.min((day.maxWind / 30) * 100, 100)}%"></div>
                                                    </div>
                                                    <span class="text-sm font-medium w-12 text-right ${day.maxWind >= 20 ? 'text-orange-400' : 'text-slate-300'}">
                                                        ${day.maxWind} mph
                                                    </span>
                                                </div>
                                            </div>
                                            <div class="ml-12 text-xs text-slate-400 space-y-1">
                                                ${day.dayWindyMins > 0 ? `<div>‚òÄÔ∏è ${formatDuration(day.dayWindyMins)}</div>` : ''}
                                                ${day.nightWindyMins > 0 ? `<div>üåô ${formatDuration(day.nightWindyMins)}</div>` : ''}
                                                ${(day.dayWindyMins || 0) === 0 && (day.nightWindyMins || 0) === 0 ? `<div>No windy time</div>` : ''}
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    `}

                    <div class="text-center">
                        <button onclick="forceRefresh()" class="text-slate-400 hover:text-amber-400 text-sm transition-colors">
                            Force Refresh
                        </button>
                    </div>
                </div>
            `;
        }

        function renderDetails(forecast) {
            const today = forecast[0];
            const emoji = today.shouldSleepInStudy ? 'üé¢' : 'üèôÔ∏è';
            
            document.getElementById('app').innerHTML = `
                <div class="max-w-2xl w-full">
                    <div class="text-center mb-8">
                        <div onclick="toggleDetails()" class="emoji-main select-none inline-block" style="font-size: 4rem;">
                            ${emoji}
                        </div>
                        <p class="text-slate-400 text-sm mt-2">Later</p>
                    </div>

                    <!-- 5-day forecast -->
                    <div class="bg-slate-800/50 border border-slate-700 rounded-2xl p-6 mb-6">
                        <p class="text-slate-400 text-sm mb-4">5-Day Forecast</p>
                        <div class="space-y-3">
                            ${forecast.slice(0, 5).map((day, idx) => {
                                const dayEmoji = day.shouldSleepInStudy ? 'üé¢' : 'üèôÔ∏è';
                                const date = new Date(day.date);
                                const dateStr = idx === 0 ? 'Tonight' : 
                                               idx === 1 ? 'Tomorrow' :
                                               date.toLocaleDateString('en-US', { weekday: 'long', month: 'short', day: 'numeric' });
                                
                                return `
                                    <div class="py-2 border-b border-slate-700/50 last:border-0">
                                        <div class="flex items-center justify-between mb-1">
                                            <div class="flex items-center gap-3 flex-1">
                                                <span class="text-3xl">${dayEmoji}</span>
                                                <span class="text-slate-300 text-sm">${dateStr}</span>
                                            </div>
                                            <div class="flex items-center gap-2">
                                                <div class="w-24 bg-slate-700 rounded-full h-1.5 overflow-hidden">
                                                    <div class="h-full ${day.maxWind >= 20 ? 'bg-orange-400' : 'bg-emerald-400'}" 
                                                         style="width: ${Math.min((day.maxWind / 30) * 100, 100)}%"></div>
                                                </div>
                                                <span class="text-sm font-medium w-12 text-right ${day.maxWind >= 20 ? 'text-orange-400' : 'text-slate-300'}">
                                                    ${day.maxWind} mph
                                                </span>
                                            </div>
                                        </div>
                                        <div class="ml-12 text-xs text-slate-400 space-y-1">
                                            ${day.dayWindyMins > 0 ? `<div>‚òÄÔ∏è ${formatDuration(day.dayWindyMins)}</div>` : ''}
                                            ${day.nightWindyMins > 0 ? `<div>üåô ${formatDuration(day.nightWindyMins)}</div>` : ''}
                                            ${(day.dayWindyMins || 0) === 0 && (day.nightWindyMins || 0) === 0 ? `<div>No windy time</div>` : ''}
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>

                    <div class="text-center space-y-2">
                        <button onclick="forceRefresh()" class="text-slate-400 hover:text-amber-400 text-sm transition-colors">
                            Force Refresh
                        </button>
                        <br>
                        <button onclick="toggleDetails()" class="text-slate-500 hover:text-slate-300 text-xs transition-colors">
                            back to simple view
                        </button>
                    </div>
                </div>
            `;
        }

        function renderError(message) {
            document.getElementById('app').innerHTML = `
                <div class="bg-slate-800 border border-red-500/30 rounded-2xl p-8 max-w-md text-center">
                    <div class="text-6xl mb-4">‚ö†Ô∏è</div>
                    <h2 class="text-xl font-semibold text-red-400 mb-2">Error</h2>
                    <p class="text-slate-400 text-sm mb-4">${message}</p>
                    <button onclick="location.reload()" class="bg-amber-500 hover:bg-amber-600 text-slate-900 font-medium py-2 px-6 rounded-lg transition-colors text-sm">
                        Try Again
                    </button>
                </div>
            `;
        }

        fetchWeatherData();
    </script>
</body>
</html>